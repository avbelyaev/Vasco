\documentclass[a4paper,14pt]{extreport} %размер бумаги устанавливаем А4, шрифт 14пунктов
\usepackage[T2A]{fontenc}
\usepackage{booktabs} % For prettier tables
\usepackage[utf8]{inputenc}%включаем свою кодировку: koi8-r или utf8 в UNIX, cp1251 в Windows
\usepackage[english,russian]{babel}%используем русский и английский языки с переносами
\usepackage{amssymb,amsfonts,amsmath,mathtext,cite,enumerate,float} %подключаем нужные пакеты расширений
\usepackage[dvips]{graphicx}
\usepackage{multirow}
\usepackage{pgfplots}

\title{Masters diploma}
\date{May 2020}
\author{Anthony Belyaev}


\usepackage{setspace} % межстрочный интервал
\setstretch{1.4}

\usepackage{geometry} % А4, примерно 28-31 строк(а) на странице
    \geometry{paper=a4paper}
    \geometry{includehead=false} % Нет верх. колонтитула
    \geometry{includefoot=true}  % Есть номер страницы
    \geometry{bindingoffset=0mm} % Переплет    : 0  мм
    \geometry{top=20mm}          % Поле верхнее: 20 мм
    \geometry{bottom=25mm}       % Поле нижнее : 25 мм
    \geometry{left=25mm}         % Поле левое  : 25 мм
    \geometry{right=25mm}        % Поле правое : 25 мм
    \geometry{headsep=10mm}  % От края до верх. колонтитула: 10 мм
    \geometry{footskip=20mm} % От края до нижн. колонтитула: 20 мм

% глубина table-of-contents и нумерования секций. чтобы попали subsubsections в TOC
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}
% нумерование секций целыми числами "0.1" -> 1
\counterwithout{section}{chapter}

\usepackage{listings} %листинги
\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  keepspaces=true,
  frame=top,
  frame=bottom,
  % !!! поддержка Юникода в листингах
  inputencoding=utf8x,
  extendedchars=\true
}


\usepackage[table,xcdraw]{xcolor}

\usepackage{graphicx} %package to manage images

\usepackage{syntax} % БНФ грамматика
\setlength{\grammarparsep}{10pt plus 1pt minus 1pt} % separation between rules
\setlength{\grammarindent}{6em} % increase separation between LHS/RHS

\usepackage{proof} % правила вывода (inference rules)

% \graphicspath{{./img/}}%путь к рисункам

\usepackage[titletoc]{appendix}
\usepackage{pdfpages}


% импортируем титульник
% \usepackage{import}





\begin{document}

    \newpage
    {
        \section*{АННОТАЦИЯ}
    }


    TODO





    \newpage
    {
      \tableofcontents
      \clearpage
    }



    % убираем подписывание номера страницы у ВВЕДЕНИЯ
    % т.е. вместо "ВВЕДЕНИЕ ...... 3" будет "ВВЕДЕНИЕ        "
    \addtocontents{toc}{\cftpagenumbersoff{ВВЕДЕНИЕ}}
    {\section*{ВВЕДЕНИЕ}}


Исторически сложилось, так, что интернет сравнительно недавно
стал неотъемлемой частью жизни. На заре компьютерной эпохи и вплоть до недавнего времени компьютеры имели достаточно ограниченную область применения

При этом развитие технологий происходит не равномерно - где-то
благодаря “цифровизации” только появляются первые компьютеры, в то время, как где-то происходит смена очередного поколения устройств и способов доступа в интернет.

Но, так или иначе, любое развитие начиналось с появления
программ на настольные компьютеры. Таким образом, исторически
сложилось, что объем программного обеспечения под настольные
компьютеры в разы превышает объем программ, работающих в сети
интернет.

Несмотря на то, что это различие постепенно снижается и в
какой-то момент появится перевес в другую сторону, на это понадобится значительное количество времени, т.к. объемы кодовых баз достигают миллионы строк на единицу программного обеспечения.

Использование программ с помощью сети интернет значительно
упрощает многие процессы как для разработчика, так и, в большей степени, для пользователя - привычные действия не требуют привязки к конкретному устройству, а лишь требуют наличия браузера и подключения к сети интернет.

При этом “перенос” программ в интернет трудозатратен и зачастую не может быть осуществлен в принципе из-за объемов кодовых баз.Автоматизация же процесса переноса ставится во главу угла, т.к. позволяет выполнить процесс с меньшими затратами. При этом гарантируется целостность целевой программы, а также сохранение ее быстродействия.

В качестве такого автоматизированного процесса может служить
компиляция - процесс переноса программ на входном языке в, как
правило, более низкоуровневую версию. В терминах данной работы под низкоуровневой программой понимается аналог исходной программы, работающий в сети интернет.

В данной работе будут исследованы аспекты подобного переноса
программ, начиная от построения математической модели и заканчивая реализацией компилятора для апробации подходов.

\newpage



{\section{ПОСТАНОВКА ЗАДАЧ ИССЛЕДОВАНИЯ}}

TODO

\newpage


{\section[ПОСТРОЕНИЕ МАТЕМАТИЧЕСКОЙ МОДЕЛИ]{ПОСТРОЕНИЕ МАТ. МОДЕЛИ}}


	В природе происходит множество процессов и явлений. Их описание чрезвычайно сложно, а попытка моделирования этих процессов затрудняется без множества существенно важных деталей. Если эти детали не учитываются или искажены, моделирование становится невозможным в принципе.

	Тем не менее, с помощью строгой формализации в соответствии с некоторыми правилам, эти процессы могут быть упрощены без потери важных деталей.

	Перевод процесса или явления в формальное описание системы называется математическим моделированием. Дисциплина «Математическое моделирование» занимается построением подобных моделей и важный момент здесь - соблюдение баланса между простотой математической модели и полнотой описываемой ею реальной системы.
	Так, упрощение модели позволяет описать ее меньшим количеством параметров, что позволяет производить вычисления с меньшими трудозатратами. Но обратная сторона - потеря «связи с реальностью», т.к. с большой вероятностью построенная модель уже не описывает процесс во всей его полноте или описывает совершенно другой процесс. Использование ее в дальнейших вычислениях может привести к неожиданным результатам, что катастрофически скажется на результатах всего исследования.

	В свою очередь сложная или переусложненная модель приводит к «удорожанию» вычислений и обесцениванию результатов, внимание может быть приковано к неключевым параметрам притом, что «проверка вручную» в случае такой системы будет невозможна. Трудозатраты - существенный фактор, т.к. При неправильном построении сложность эксперимента может оказаться дороже потенциальных результатов. Очевидно, если проведение исследования более затратно, чем выгода от получения результатов исследования, то такое исследование несостоятельно.

{\subsection{Аксиоматическая семантика}}

	Очевидно, выполнение программы, как и процесс ее компиляции могут быть формализованы математическим описанием. Существенный фактор здесь состоит в том, что рассматривается выполнение программы, написанной в функциональном стиле, т.к. этот «стиль» имеет тесную связь с математикой. Об этом будет сказано чуть позднее в данной работе. Но для начала необходимо дать определение области, в рамках которой будет происходить работа и все дальнейшие эксперименты и проверки гипотез.

	\textbf{Информатика} (Computer Science, CS) - широкая область наук, включащая все аспекты обработки информации от теоретического исследования алгоритмов и структур данных до практической реализации программного и аппаратного обеспечения.

	В рамках данной работы рассматривается подобласть информатики - \textbf{Теоретическая информатика} (Theoretical Computer Science, TCS) - чуть более узкая область, занимающаяся исследованиями, связанными с математическими, логическими и формальными проблемами информатики. Вот лишь некоторые из направлений:

\begin{itemize}
    \item Исследование алгоритмов и теория вычислимости
    \item Теория языков программирования, формальных языков
    \item Вычислительная сложность
    \item Логика и формальная семантика
\end{itemize}

Нас в рамках данной работы интересует последний пункт, включающий логику высказываний, логику предикатов и, в частности, формальную семантику. Эти направления имеют тесную связь с практическими задачами, например, построением компиляторов, что является одной из задач, поставленной в данной работе.

	Таким образом, область работы была сформулирована в общем смысле. Тем не менее, поскольку теоретическая информатика достаточно широка, как область исследования, необходимо перейти к направлению в более узком смысле. В данном случае нас интересует подобласть, называемая «семантикой».

	\textbf{Семантика} (Semantics) - дисциплина более прикладная к теме данной работы. Она занимается формализацией значений конструкций языков программирования путем построения их математических моделей и включает следующее:

\begin{itemize}
    \item Определение семантических моделей
    \item Отношения между семантическими моделями
    \item Отношения между вычислимостью и нижележащими математическими структурами, например, логикой и теорией множеств
\end{itemize}



Семантика описывает процессы, выполняемые компьютером во время исполнения программы и помогает понять значения конструкций, указанных, например в Листинге \ref{constr}.



\begin{lstlisting}[caption={Примеры конструкции языка программирования}, label={constr}]
if 1 == 1 then S1 else S2

i=0; while(i < 5)do{ i++; }

i=0; do{ i++; }while(i <= 4);
\end{lstlisting}


	Так, семантика позволяет «улавливать смысл» выражений и понять, что выполнение конструкции $if..then..else..$ эквивалентно выполнению лишь $S1$, т.к. условие $1 = 1$ всегда истинно. А 2 цикла ниже (первый цикл - $while..do..$ - с предусловием, второй - $do..while..$ - с постусловие) эквивалентны между собой логически, хотя и отличаются семантически.
	Но процессы, происходящие во время выполнения программы могут быть описаны с разных сторон. Следовательно, и семантика, описывающая их делится на подвиды. Рассмотрим лишь некоторые из них.

	\textbf{Операционная} - наиболее распространенный вид семантики. Он используется для связывания синтаксических конструкций языка программирования с некоторой абстрактной машиной (автоматом), на которой выполняются программы на этом языке. Семантика в данном случае определяет набор правил, в соответствии с которыми работает абстрактная машина.
	Более формально, автомат, находясь в некотором начальном состоянии , задает значение терма (смысл конструкции языка) путем перехода в конечное состояние.

% \begin{figure}[h]
% \centering
% \includegraphics[width=0.7\textwidth]{automata-1.png}
% \caption{что это за пример}
% \label{nier-1}
% \end{figure}

	Следующий вид семантики - \textbf{денотационная} (denote, обозначение). Она занимается сопоставлением выражений программы с математическими объектами. В качестве значения терма принимается некий математический объект (например, функция или число) и задается функция интерпретации этого объекта, переводящая их в другую область.
	В случае языка программирования, смысл выражений на нем описывается на другом языке - метаязыке, задающем значения конструкций входного языка. Это находит отражение в конструировании компиляторов, но не входит в основное содержание данной работы.

	\textbf{Интерпретационная семантика} описывает конструкции языков программирования высокого уровня в терминах языков низкого уровня, например, ассемблера или машинных кодов. Очевидно, это находит отражение в самых прикладных аспектах программирования, но, тем не менее, так же не является основным направлением исследования.

	\textbf{Аксиоматическая семантика} - интересующее нас в данной работе направление - занимается связыванием практических аспектов - синтаксических конструкций языка программирования - с математическим смыслом через набор аксиом, правил вывода. Эта семантика не разделяет смысл конструкций и логические формулы, их описывающие. Наоборот, вывод эти формул и является смыслом конструкций языка. Каноническим примером аксиоматической семантики является логика Хоара (Hoare logic) - о ней будет сказано далее.

	Таким образом, по аналогии с доказательством теорем, аксиомы и правила вывода (обозначающие операторы программы), будучи примененными к некоторым входным переменным (удовлетворяющим некоторым ограничениям) порождают выходные переменные, тоже удовлетворяющие соответствующим ограничениям.

	Результат выполнения программы в свою очередь является доказательством того, что выходные данные представляют значения функции, вычисленной по входным данным.




{\subsection{Выбор модели вычислений}}

	Все способы описания поведения программ, которые были рассмотрены выше так или иначе связаны с конкретными реализациями программ так или иначе, привязанных к какому-либо языку или стилю написания кода.

	Но дело в том, что если привязываться к этим параметрам, можно получить множество разных моделей одной и той же программы - все они в конечном счете выполняют одну и ту же логику, но то, как программы реализованы влияет на то, как они исполняются. Этого необходимо избежать и одним из способов абстрагироваться от этого является переход к конкретной модели вычислений, как к обобщенной реализации программы.

	Модель вычисления описывает зависимость выходных значений математической функции от входных. При этом, работа и эффективность любого алгоритма в рамках модели вычислений может быть оценена независимо от реализации и без привязки к конкретному языку и технологии.


	{\subsubsection{Конечный автомат}}

Конечные автоматы (Finite state machine, FSM) широко применяются при моделировании систем и вычислений. Они представляют из себя математическую абстракцию устройства, имеющего один вход и выход и в любой момент времени находящегося в одном состоянии из всего множества возможных. Автомат описывается в терминах
\begin{itemize}
    \item входа
    \item выхода
    \item множества операций по переводу входных данных в выходные
\end{itemize}

Широко известными примерами автоматов являются \textbf{Машина Тьюринга} - <<классическая>> модель вычисления, <<перебирающая>> ленту из входных символов согласно заданным правилам и \textbf{Виртуальная машина} - программная реализация абстрактного автомата посредством интерпретации.

Абстрактные автоматы подходят для моделирования систем, работающих \textit{последовательно} и имеющих сравнительно небольшое количество дискретных состяний. Каждое из этих состяний имеет отношение к детали моделируемой задачи.

Более формально, автомат имеет
\begin{itemize}
    \item конечное число дискретных состояний $S_1, \dots, S_k$, одно из которых является начальным состоянием
    \item конечное число $m$ входных символов $I_1, \dots, I_m$
    \item конечное число $n$ выходных символов $O_1, \dots, O_n$
    \item набор правил перехода, определяющих следующее состояние \\ $\bar s \ (s,I_1, \dots, I_m)$ для каждого состояния $s$ и набора входных данных $(I_1, \dots, I_m)$
    \item набор правил вывода, определяющих выходные значения \\ $O_1(s,I_1,\dots,I_m), \dots, O_n(s,I_1,\dots,I_m)$ для каждого состояния $s$ и входов $I_1,\dots,I_m$
\end{itemize}

Автомат начинает работу с начального состояния $S_1$ и выполняет переход в новое состояние $\bar s$ в зависимости от текущего состояния $s$ и текущего входа. Выходные значения продиктованы текущим состоянием.

Распространенным представлением автомата является граф, узлы которого представляют состояния, а ребра - переходы между состояниями.

Несмотря на то, что автомат по определению  может выдавать выходные значения, основываясь одновременно и на входных значениях, и на текущем состоянии, выходные значения  обычно отражают только текущее состояние, но не входные значения. Такие автоматы получили название \textbf{Автоматы Мура} (Moore machine). Диаграмма таких автоматов обычно содержит одновременно название состояния и выходное значение в нем.
% TODO ссылка на литру https://computationstructures.org/notes/fsms/notes.html

\begin{figure}[!tbp]
  \centering
  \begin{minipage}[b]{0.55\textwidth}
    \includegraphics[width=1.0\textwidth]{moore-1.jpg}
    \caption{Автомат Мура}
    \label{moore-1}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.41\textwidth}
    \includegraphics[width=1.0\textwidth]{mealy-1.jpg}
    \caption{Автомат Мили}
    \label{mealy-1}
  \end{minipage}
\end{figure}

В противоположность в \textbf{автоматах Мили} (Mealy machine) выходное значение одновременно зависит от состояния и входа. На диаграммах это отражается в маркировке ребер. На Рисунках \ref{moore-1} и \ref{mealy-1} показаны представления обоих типов автоматов.

Возможность концептуально задать автомат любого размера и, соответственно, провести вычисления практически любых масштабов делает конечные автоматы неплохими кандидатами в качестве модели вычислений. Автоматы хорошо изучены и широко используются. \\


Но, говоря о вычислениях в общем смысле, встает вопрос, подходят ли автоматы для моделирования  \textit{всех возможных} вычислений. Если любые возможные вычисления могут быть выполнены некоторым конечным автоматом, значит ли это, что необходимо из перечислимого набора автоматов лишь  выбрать подходящий? Такой подход, очевидно, игнорирует практические аспекты, такие, как затраты и производительность.

Чтобы ответить на этот вопрос, необходимо изучить недостатки конечных автоматов. Для этого представим следующую задачу: разработать автомат, проверяющий сбалансированность скобочной последовательности. Так, последовательность <<(()())>> является сбалансированной, а <<()())>> -- не является. Для простоты можно закодировать открывающуюся и закрывающуюся скобки с помощью <<1>> и <<0>>.

Сложность этой задачи состоит в ограниченности хранилища автомата. Если скобочная последовательность состоит из $k$ элементов, потребуется не менее $k+1$ разных состояний для моделирования каждого шага процесса.

С практической точки зрения, при наличии ограничений, автоматы подходят для моделирования вычислений. Любой автомат несет хранилище строго определенных размеров. Балансировка скобочной последовательности это простой пример -- любая строка конечного размера может быть проверена некоторым автоматом, но для любого такого ограничения на размер строки, мы можем подобрать строку, которая, будучи все еще ограниченной, не укладывается в хранилище автомата.

Таким образом, необходимо изучить альтернативные модели вычислений.


{\subsubsection{Сети Петри}}

Для моделирования параллельных вычислений некоторое время применялись сети Петри (Petri nets) -- граф, состоящий из вершин двух типов - \textit{позиций} и \textit{переходов}, соединенных ребрами. При этом вершины одного типа не могут быть соединены непосредственно. Позиции в данном случае схожи с состояниями автомата, но это не совсем так. В данном случае в позициях могут быть расположены \textit{метки} (или токены), способные перемещаться по сети. Состоянием же всей сети Петри называется распределение метод по позициям в отдельный момент времени.

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{petri.png}
\caption{Сеть Петри}
\label{petri}
\end{figure}

На Рисунке \ref{petri} представлен пример сети Петри, тройки вида $N = (P,T,F)$. Здесь $P=(P_1, \dots, P_4)$ -- \textit{позиции}, полоски $T=(T_1, T_2)$ -- \textit{переходы}, а черные точки ($F$) -- \textit{метки}.
% TODO ссылка на литру http://www.1024cores.net/home/scalable-architecture/case-study-actor-scheduler

События в сети происходят либо мгновенно, либо размеренно. То, что события могут произойти одновременно, представляет сложность в восприятии и использовании: на одном атомарном шаге системы токены (метки) из одной позиции могут полностью исчезнуть и появиться в других позициях.

Так же, по аналогии с конечными автоматами, сети Петри подходят для моделирования потока управления (control flow), но не для представления данных в конкретный момент времени.

Тем не менее, параллельные вычисления получают все большее распространение, т.к. по многим факторам являются более эффективными, нежели последовательные. И для их моделирования была разработана акторная модель, как своего рода потомок сетей Петри.


{\subsubsection{Акторная модель}}

Акторная модель применяется для моделирования параллельных вычислений и строится вокруг понятия <<актор>> (actor -- актер, англ.) -- примитива параллельного исполнения.

Концептуально она определяет набор правил, согласно которому взаимодействуют компоненты системы -- \textbf{акторы}. Акторы принимают \textit{сообщения} и, основываясь на них, выполняют некоторые действия. Идея акторов имеет много общего с принципами Объектно-ориентированного программирования (ООП) с тем лишь различием (ограничением), что акторы являются независимыми друг от друга, не разделяют общего состояния, а их внутреннее состояние не может быть изменено действиями другого актора.

Важным замечанием явлется то, что несмотря на то, что несколько акторов одновременно могут работать параллельно, каждый актор вам по себе работает последовательно. Таким образом, если актору будут переданы, например, 3 сообщения, 3 ответных действия будут выполнены последовательно одно за другим. Чтобы выполнить эти действия параллельно, необходимо отправить сообщения трем разным акторам. Пример небольшой акторной системы представлен на Рисунке \ref{actors-1}.

\begin{figure}[h]
\centering
\includegraphics[width=0.4\textwidth]{actors.png}
\caption{Акторная система}
\label{actors-1}
\end{figure}

Акторная модель находит широкое применение в прикладной разработке, а двумя самым известными ее реализациями являются язык Erlang и Akka -- библиотека для языков JVM (Java, Scala и другие).

% TODO ссылка на литру https://www.brianstorti.com/the-actor-model/
Erlang, где изначально появились акторые системы, превносит философию "позвольте программе сломаться" (let it crash). Это проявляется в том, что разработчику нет необходимости предугадывать все возможные поломки программы и действия в ответ на них. Erlang позволяет отдельным компонентам программы  (акторам) <<ломаться>>, но делает это таким образом, чтобы поломка была видима для вышестоящего актора и он мсмогожет отрегаировать на нее соответствующим образом (например, перезапуском актора или отправкой сообщения другому актору). Таким образом, поломки становятся обычным порядком вещей и не являются чем-то критичным для всей системы.

Каждый актор работает полностью независимо от остальных и его поведение или поломка полностью изолированы от всей остальной системы. При этом актор может даже не находиться на одной физической машине с остальной системой.

Все это позволяет строить масштабные и масштабируемые самовосстанавливающиеся (self-healing) системы. Платой за это является значительное концептуальное усложнение системы, сложность восприятия, сложность разработки и отладки.



{\subsubsection{Логика Хоара}}

Логика Хоара является формальной системой логических правил для доказательства корректности программ. Логика Хоара основана на т.н. <<тройках Хоара>> следующего вида
$$\{ P \} C \{ Q \}$$
где $P$ является утверждением предусловия, $C$ -- командой, $Q$ -- утверждением постусловия. Т.е., если предусловие выполнено, то выполнение команды сделает постусловие выполнимым.

Логика Хоара включает аксиомы и правила вывода для большинства конструкций среднего императивного языка программирования., например:
$$
\infer{\{P'\}S\{Q'\}}{%
    P' \rightarrow P, \{P\} S \{Q\}, Q \rightarrow Q'
}
$$

Условная конструкция:
$$
\infer{\{P\} if \ B \ then \ S \ else \ T \ endif \{Q\}}{%
    \{B \wedge P \} S \{Q\}, \{ \lnot B \wedge P \} T \{ Q \}
}
$$

Цикл \texttt{while}:
$$
\infer{\{P\} while \ B \ do \ S \ done \{ \lnot B \wedge P \}}{%
    \{B \wedge P \} S \{P\}
}
$$

Правило композиции:
$$
\infer{\{P\} S \ ; \ T \{ R \}}{%
    \{P \} S \{Q\}, \{Q \} T \{R\}
}
$$

Тем не менее, тройки Хоара подходят для представления императивных конструкций, и они не рассчитаны на применение в доказательстве функциональных программ, поэтому они приведены лишь для ознакомления.


{\subsubsection{Лямбда-исчисление}}

% TODO ссылка на литру https://plato.stanford.edu/entries/lambda-calculus/
Лямбда-исчисление (lambda calculus, $\lambda$ calculus) это формальная система записи выражений в математической логике. Она была введена в обращение математиком Алонцо Черчем (Alonzo Church) в 1930х годах и до сих пор является одновременно простой, при этом универсальной  моделью вычислений и формирует теоретическую модель для многих функциональных языков программирования.

В основе т.н. \textbf{<<чистого>> лямбда-исчисления} лежит простая нотация задания функций и их применения, а основные идеи - применение функции к аргументу и задание новой функции с помощью абстракции.

При этом такого понятия, как переменные и константы - нет и для того, чтобы представлять числа используется т.н. кодирование Черча (Church encoding). Представленные с помощью кодирования Черча целые числа называются \textbf{нумералами Черча} -- функциями высшего порядка, количество применений которых к аргументу обозначает натуральное число. В Таблице \ref{enc} приведены примеры термов такого кодирования.

\begin{table}[]
\caption{\label{enc}Нумерлы Черча}
\centering
\begin{tabular}{|r|l|}
\hline
Число & Лямбда-выражение                        \\ \hline
0     & \lambda f . \ \lambda x . \ x           \\ \hline
1     & \lambda f . \ \lambda x . \ f \ x        \\ \hline
2     & \lambda f . \ \lambda x . \ f(f \ x)    \\ \hline
3     & \lambda f . \ \lambda x . \ f(f(f \ x)) \\ \hline
n     & \lambda f . \ \lambda x . \ f^n \ x     \\ \hline
\end{tabular}
\end{table}

Поскольку число представляется количеством применений функции, то операции над числами схожи с операциями над степенями:
$$m + 1 = f^{n+1}x=f(f^nx) = succ \ n \ f \ x = f(n \ f \ x) = \lambda n. \ \lambda f. \ \lambda x. \ f(n \ f \ x)$$
$$m + n = f^{m+n}x = f^m(f^n \ x) = plus \ m \ n \ f \ x = \lambda m. \ \lambda n. \ \lambda f. \ \lambda x. \ m \ f(n \ f \ x)$$

Логический же тип данных представляется т.н. Church booleans - функциями с двумя аргументами, где истина (True) обозначает выбор первого аргумента, а ложь (False) -- выбор второго аргумента:
$$true = \lambda a. \ \lambda b. \ a$$
$$false = \lambda a. \ \lambda b. \ b$$

Тезис Тьюринга-Черча утверждает, что любой вычислимый оператор может быть представлен в кодировке Черча. Благодаря этому, в дополнение к функциям, единственному <<типу данных>>, мы способны выразить любую другую сущность через применение функций.

Лямбда-исчисление, расширенное введением описанных выше сущностей (<<встроенных>> функций, переменных и констант) называется \textbf{прикладным лямбда-исчислением} (applied lambda calculus). Все описанное в дальнейшем будет рассаматриваться в рамках именно такого исчисления.
Грамматика прикладного $\lambda$-исчисления описывается правилом со следующими тремя альтернативными цепочками символов: \\

\begin{grammar}

<expr> ::= lambda  <variable> .  <expr>
        \alt <expr>  <expr>
        \alt <variable>

\end{grammar}

где \texttt{<expr>} -- выражение, а \texttt{<variable>} -- переменная.

Для начала можно рассмотреть простейший пример $\lambda$-терма:
$$\lambda x[x^2-2x+5]$$

Оператор $\lambda$ позволяет нам задать функцию, абстрагировавшись от значения $x$. Таким образом, мы можем задать выражение $x^2-2x+5$, ожидающее значения $x$. Если мы, например, зададим значение $x=2$, то осуществится \textit{применение} функции к аргументу и будет получен результат
$$(\lambda x[x^2-2x+5])2 \rightarrow 2^2-2*2+5=4-4+5=5$$

Более формально, концепции лямбда-исчисления следующие.

В лямбда-исчислении присутствуют \textbf{переменные} (например, $x$), обозначающие значения.

\textbf{Абстракция}: $\lambda x.M$ -- выражение, задающее функцию, где $x$ -- аргумент, $M$ -- тело функции. Важно заметить, что у этой функции нет названия, т.е. это <<анонимная>> функция. Пример выше:
$$\lambda x . x^2-2x+5$$

\textbf{Аппликация}: $f \ a$ -- применение функции к аргументу. Здесь $f$ --функция, $a$ -- аргумент.
$$(\lambda x . x^2-2x+5)2$$

\textbf{$\beta$-редукция} (так же известная, как $\beta$-конверсия) -- правило, по которому производится подстановка, записывается следующим образом:
$$(\lambda x[M])N \rightarrow M[x:=N]$$

И представляет из себя замену связанных вхождений $x$ внутри тела функции $M$ на аргумент $N$. Такой процесс так же называется нормализацией. Существуют и ненормализуемые термы, например $(\lambda x . \ xx)(\lambda x . \ xx)$ нормализуется в себя же.


Важным моментом является то, что аргумент всегда строго один. Но, чтобы задать функцию от, нескольких аргументов, необходимо воспользоваться техникой \textit{каррирования} (currying). Применим ее для следующей функции:
$$ (x,y,z) \rightarrow x^2 + y^2 + z^2$$

Эта функция от трех аргументов принимает следующий вид в нотации лямбда-исчисления:
$$ \lambda x . \lambda y . \lambda z . x^2+y^2+z^2 $$

Последняя важная концепция, которую стоит рассмотреть, связана с математической логикой. Она заключается в наличии свободных и связанных переменных.

В математической логике вхождение переменной в формулу называется \textbf{связанным}, если оно находится в области действия квантора, использующего эту переменную. Иначе, вхождение переменной называется \textbf{свободным}.

В случае лямбда-исчисления абстракция предоставляет нам возможность связывать переменные в функции (формуле). Так, например в функцию
$$ \lambda x . x^2+y+5 $$

переменная $y$ входит свободно, а переменная $x$ -- связанно. Важно заметить, что до тех пор, пока мы не связали $y$ с конкретным значением, вычислить функцию мы не сможем. \\



Мы рассмотрели лишь несколько концепций лямбда-исчисления, но необходимо так же рассмотреть и его практическую составляющую в рамках данной работы. Для этого рассмотрим использование лямбда-исчисления в программировании.

Пусть существует некоторая нотация, которая позволяет нам записать следующие действия: конструирование списка (пары, если точнее), получение первого элемента получившейся конструкции и получение последней части конструкции (всех элементов, кроме первого, если быть точнее). Запишем эти команды на Листинге \ref{cons}

\begin{lstlisting}[caption={Действия над парой элементов}, label={cons}]
(cons p q)
> (p q)
(head (cons p q))
> p
(tail (cons p q))
> q
\end{lstlisting}

Так, с помощью операции $cons$ мы задали упорядоченную пару $(p, q)$ из элементов $p$ и $q$. С помощью операции $head$ получили первый элемент пары (т.н. <<голову>> списка), в данном случае -- элемент $p$. С помощью $tail$ получили последний элемент пары (т.н. <<хвост>> списка), в данном случае -- элемент $q$.

Интересен тот факт, что эти операции, представляющие из себя простейшую программу, могут быть с легкостью перенесены на лямбда-нотацию в виде лямбда-абстракций:
$$CONS=\lambda a . \ \lambda b . \ \lambda f . \ f \ a \ b$$
$$HEAD=\lambda c . \ c (\lambda a . \ \lambda b . \ a)$$
$$TAIL=\lambda c . \ c (\lambda a . \ \lambda b . \ b)$$

По аналогии с записью \texttt{(head (cons a b))} выше, мы можем выполнить лямбда-аппликацию, т.е. для некоторой пары $(p,q)$ вычислить ее первый элемент следующим образом:
$$HEAD(CONS \ p \ q)$$
$$(\lambda c . \ c (\lambda a . \ \lambda b . \ a))(CONS \ p \ q)$$
$$CONS \ p \ q \ (\lambda a . \ \lambda b . \ a)$$
$$(\lambda a . \ \lambda b . \ \lambda f . \ f \ a \ b) \ p \ q (\lambda a . \ \lambda b . \ a)$$
$$(\lambda b . \ \lambda f . \ f \ p \ b) \ q (\lambda a . \ \lambda b . \ a)$$
$$(\lambda f . \ f \ p \ q) (\lambda a . \ \lambda b . \ a)$$
$$(\lambda a . \ \lambda b . \ a) \ p \ q$$
$$(\lambda b . \ p) \ q$$
$$p$$

То есть, путем применения лямбда-аппликации и бета-редукции мы по сути вычислили значение выражения, представляющее из себя простейшую программу на Листинге \ref{cons}. Вычисление <<хвоста>> пары --  \texttt{(tail (cons a b))} -- очевидно и приводить его здесь не имеет смысла.

Важное наблюдение: для представления такой программы нам не понадобилось сохранять промежуточные вычисления, т.к. каждая <<итерация>> была самодостаточной и полностью описывала шаг процесса. Т.е., нам не понадобились никакие переменные, в которых мы бы сохраняли значения и которые мы бы модифицировали.

При рассмотрении предыдущих моделей вычисления (с помощью автоматов и машины Тьюринга, с помощью сетей Петри и акторов) мы видели с какой простотой и выразительностью можно моделировать вычисления, но большой проблемой было хранение промежуточных вычислений (т.н. <<состояния программы>> (program state) в программировании) в каждый момент вычисления.

Пример с лямбда-исчислением достаточно примитивен и при этом относительно <<многословен>>, но он показывает <<мощность>> и выразительность лямбда-исчисления для моделирования программ.

Важнейшим же аспектом является \textbf{отсутствие состояния программы}. По сути мы <<избаваились от данных>>. В этом заключается преимущество этой модели -- мы по-прежнему можем моделировать сложные вычисления (программы) без необходимости заботится о хранении промежуточных вычислений

Таким образом мы можем завершить поиск способа представления программы с помощью математической модели и остановиться на лямбда-исчислении, как на итоговом варианте.


\newpage

\section[ИНТЕРПРЕТАЦИЯ ЛЯМБДА-ИСЧИСЛЕНИЯ]{ИНТЕРПРЕТАЦИЯ \\ ЛЯМБДА-ИСЧИСЛЕНИЯ}

Как было отмечено ранее, лямбда-исчисление является теоретической основной многих функциональных языков программирования, но необходимо разобраться для чего необходима эта теоретическая база.

Успех разработки программного обеспечения заключается в корректности последнего. Эта корректность может быть достигнута путем тестирования. При этом сложные программы представляют из себя <<черный ящик>> и их тестирование может быть сведено с проверке работы против некоторого ограниченного набора входных данных. Сама же программа внутри может быть слишком сложной для автоматизированного тестирования или написанной непригодным для такого тестирования способом. Значит, ошибки в ней не могут быть выявлены программным путем.

Тестирование императивных программ (написанных, например, на Java, C++ или Python), как правило сопровождается просмотром исходного кода программ -- логика в них может быть сложной для восприятия, запутанной, с нарушенными абстракциями. При этом у императивной программы есть состояние (program state) и бывает невозможно вызвать процедуру дважды подряд с одними и теми же аргументами и ожидать одинаковый результат, т.к. процедура одновременно зависит от состояния и меняет его. Таким образом, тестирование сводится к проверке в стиле <<\textit{вызовет ли исключение этот набор входных данных? вызовет ли этот?}>>. Это достаточно низкоуровневое тестирование, которое скорее говорит о правильности реализации, но не доказывает наличие или отсутствие важных свойств программы. Эдсгер Дейкстра (Edsger Dijkstra) высказывался следующим образом: <<\textit{Тестирование программы показывает наличие ошибок, а не их отсутствие}>>.

Также это значит, что ее свойства не могут быть выведены и доказаны автоматически. Что при это может сделать разработчик для доказательства корректности? Наиболее эффективным решением является использование \textbf{типизированного функционального программирования}.

Система типов языка программирования позволяет создавать корректное программное обеспечение, которое удовлетворяет поставленным требованиям. Типы как правило имеются у выражений, переменных, функций. При этом т.н. \textbf{соответствие Карри-Говарда} позволяет делать выводы о корректности программы по аналогии с математическими доказательствами. Типы в данном случае -- высказывания, а переменных этих типов -- доказательства этих высказываний.

Таким образом, если программа компилируется, т.е. проходит проверку типов, то это доказывает, что у программы имеются свойства, присущие этим типам. Тогда, для заданных входных данных программа вычисляет выходных данные. И эти выходные данные являются доказательством высказывания соответствующего типа. Благодаря этому, функциональными языками программирования можно оперировать основываясь на типах функций, нежели на конкретной их реализации.

Простой пример в данном случае -- функция, принимающая полиморфный аргумент типа $T$ и возвращающая значение того же типа $T$:
$$y \ :T = f(x \ :T)$$
В случае, если на $T$ не накладывается никаких ограничений, единственно возможной реализацией является тождественное отображение (identity function):
$$id(x)=x$$
Т.к. о $T$ -- типе $x$ -- ничего не известно заранее, то и никаких выводов о корректности функции (кроме отображения $id$) сделать нельзя.

Но, если $T$ является конкретным типом, то он накладывает ограничения на действия, которые можно совершить над $x$. В таком случае все еще можно написать некорректную реализацию функции $f$, но она не пройдет проверку системой типов во время компиляции. Это существенно ограничивает количество некорректных реализаций функции.

В качестве примера можно рассмотреть язык Scala. Он позволяет писать программы в функциональной парадигме, но он пытается одновременно быть функциональным и императивным. Это способствует простоте его восприятия и удобстве работы с ним в рамках императивной парадигмы. Но функциональная его парадигма принесена в жертву.

Пусть есть функция, принимающая целочисленный аргумент и возвращающая целое число. Эта функция может иметь множество сторонних эффектов (side effects), таких как изменение глобальных переменных, печать в поток вывода, выбрасывание исключений. Компилятор в данном случае лишь проверяет типы входных и выходных данных и делает заключение о свойствах функции, основываясь на них. Но не гарантирует, что других свойств нет.

Это не дает возможность делать никаких выводов о поведении, основываясь на сигнатуре функции - всегда необходимо смотреть на ее реализацию и на реализацию тех функций, которые вызываются внутри. Как результат, абстракции не работают, а без абстракций сложно строить по-настоящему сложные вещи.

Это прямо противоположно тому, как происходят доказательства в математике: если бы математик не мог опираться на меньшие теоремы (леммы) при доказательстве больших, и должен был бы каждый раз смотреть на доказательства этих лемм, то не было бы никакого смысла иметь леммы и прочие отдельные теоремы. Как результат, математика не была бы столь разнообразной и комплексной.



\subsection{Функциональное программирование}

 Функциональное программирование является парадигмой, в которой программы являются композициями функций. Такой подход существенно отличается от классического императивного программирования, где функции являются скорее сгруппированным набором последовательных  инструкций.

 Выражения в ФП возвращают значения, нежели изменяют состояние программы
 $$y = f(g(h(x, z))) \leftrightarrow result = write(process(read(a, b)))$$

 Концепции ФП базируются вокруг функциональной чистоты (functional purity), которая позволяет трактовать функции в математическом смысле -- т.е. детерминированными, чистыми. Результат выполнения таких функций строго зависит от аргументов и не меняет общего состояния программы (отсутствует как таковой program state), не вызывает побочных эффектов, примеры которых были рассмотрены ранее.

 Программы, написанные в функциональной парадигме как правило содержат меньше ошибок, проще в тестировании, т.к. всецело зависят от входных данных и могут быть формально верифицируемы.

 Концепции функционального программирования следующие:
 \begin{itemize}
     \item функции высших порядков -- функции могут принимать функции в качестве аргументов и возвращать функции в качестве выходных значений.

         \item каррирование (currying) -- техника позволяющая выразить функцию с арностью аргументов больше 1 путем частичного применения функций с одним аргументом. Эта техника берет свое начало в лямбда-исчислении, и ранее была затронута в работе

     \item чистые функции и отсутствие состояния программы -- концепция, рассмотренная выше
     \item рекурсия -- аналог циклов в императивном стиле, тесно связанный с системой типов

         \item хвостовая рекурсия и хвостовые вызовы функций -- способ оптимизации работы программы,связанный с практическим выполнением функциональных программ процессором с последовательным выполнением инструкций.

     \item система типов -- функции полностью определены своими сигнатурами, а процесс компиляции состоит в проверке типов. Таким образом, компиляция программы тесно связана с ее формальной верфикацией и проверкой корректности. Алгебраические типы данных расширяют систему типов комплексными типами-произведениями (product type), например, парами и кортежами, которые были рассмотрены ранее (\texttt{cons}) и типами-суммами (sum type), например, объединениями.
 \end{itemize}


Первым функциональным языком программирования (и вторым языком программирования в общем смысле, после FORTRAN) считается \textbf{Lisp} (LISt Processing) -- язык, разработанный Джоном МакКарти (John McCarthy) в MIT в 1958 году. Задумывалась разработка системы программирования для символьных вычислений, а именно символьного дифференциорования.

% TODO ref to page 6 of  https://www.cs.kent.ac.uk/people/staff/dat/tfp12/tfp12.pdf
Выражения на языке Lisp строятся с помощью т.н. S-выражений (S-expressions) --структур, состоящих из автомов и обозначающих и операции и данные. В первоначальной реализации язык основывался не на лямбда-исчислении, а на теории Клини о <<рекурсивных функциях первого порядка>>, несмотря на использование ключевого слова \texttt{LAMBDA}.

Язык Lisp остался в истории и стал основой для множества диалектов, многие из которых используются до сих пор, самыми известными из которых являются Scheme и Clojure.

\subsubsection{Scheme}

% TODO ref to extended lambda calusulus
Scheme является минималистичным диалектом языка Lisp, разработанный так же в MIT. Авторы языка -- Гай Стил (Guy Steele) и Джеральд Сассман (Gerald Jay Sussman) -- впервые представили его в своей работе <<Scheme: An Interpreter for Extended Lambda Calculus>>

Семантика языка, в отличие от первой версии Lisp, сразу была основана на лямбда-исчислении, см. Листинг \ref{scm-intro}
$$(\lambda f. \ (\lambda x. \ f \ x \ a))$$

\begin{lstlisting}[caption={Лямбда-абстракция на языке Scheme}, label={scm-intro}]
(lambda (f)
    (lambda (x)
        (f x a)))
\end{lstlisting}


Благодаря этому Scheme можно даже считать имплементацией лямбда-исчисления, а большинство выкладок и формул, рассмотренных ранее могут быть с точностью до синтаксиса записаны и вычислены на языке Scheme.


Простота, минималистичность и сравнительное небольшой набор примитивов в ядре языка обеспечили ему будущее не только в академических кругах. Так, он встречается в качестве языка сценариев и расширений в графических приложениях, таких, как AutoCAD и GIMP.

У языка есть множество реализаций под разные нужды, например, Chicken Scheme, Guile, Chez Scheme и Racket.

В данной работе будет использоваться Scheme версии R6RS в реализации \textbf{Racket}, т.к. Racket является наиболее прикладной имплементацией, при этом поддерживает статически-проверяемые аннотации типов (Typed Racket) и поставляется в т.н. формате <<batteries included>>, т.е. со средой разработки, богатой библиотекой и всем необходимым для работы в одном комплекте.


\subsection{Правила вывода}

% Как было упомянуто ранее, доказать корректность императивной программы достаточно сложно. При этом проверку на корректность функциональной программы автоматически выполняет компилятор -- в функциональном программировании нет необходимости в инструменте верификации, отдельном от самой спецификации языка.

В дальнейшей работе мы будем использовать язык Scheme в качестве основного инструмента, т.к. математическими моделями программ, рассматриваемых в данной работе является абстракции лямбда-исчисления, а язык Scheme, как было отмечено ранее, можно считать фактически программной реализацией лямбда-исчисления.

Рассмотрим следующую программу на диалекте Typed Racket языка Scheme, поддерживающем аннотирование типов:

\begin{lstlisting}[caption={Конструирование объекта Point}, label={pt-1}]
(struct Point ([x :Int]
               [y :Int]))

(make-point x y)
> Point
\end{lstlisting}

На Листинге \ref{pt-1} представлена структура \texttt{struct Point}, описывающая точку с целочисленными координатами $x$ и $y$. Так же существует функция \texttt{make-point}, <<собирающая>> точку по двум координатам. То есть, эта функция фактически отображает \texttt{Int} в \texttt{Point}. Уйдя от записи на языке Scheme мы можем представить эту же функцию, как правило вывода:
$$
\infer{makePoint \ x \ y :Point}{%
    x \ :Int & y \ :Int
}
$$
Здесь \textbf{посылка} -- два целых числа, \textbf{вывод} -- точка в пространстве. Как видно, отображение более, чем однозначное.

Теперь добавим 2 функции для получения координаты $x$ и $y$ этой точки. Пусть функции имеют названия \texttt{point-x} и \texttt{point-y}. Запишем их следующим образом на Листинге \ref{pt-2}.

\begin{lstlisting}[caption={Получение координат точки}, label={pt-2}]
(point-x (Point x y)
> x :Int
(point-y (Point x y)
> y :Int
\end{lstlisting}

Эти функции, как можно заметить, отображают объект типа Point в целое число. Следовательно, их тоже можно записать в виде правил вывода:

\begin{equation*}
\infer{pointX \ p \ :Int}{%
    p \ :Point
}
\qquad  % разместить 2 формулы рядом
\infer{pointY \ p \ :Int}{%
    p \ :Point
}
\end{equation*}

Далее рассмотрим задание анонимной функции (лямбда-фукнции) таким же образом. На Листинге \ref{pt-3} представлено связывание анонимной функции с переменной $f$.
\begin{lstlisting}[caption={Задание фукнции}, label={pt-3}]
(define f
    (lambda ([x :Int]) (* x 5)
\end{lstlisting}

Функция принимает целочисленное значение $x$ и умножает его на число 5, возвращая результат. Таким образом, функция принимает Int и результатом умножения все так же остается Int. Тогда, можно записать ее с помощью следующего правила вывода:
$$
\infer{\lambda x . \ x \times 5 \ :Int \rightarrow Int}{%
    \deduce{x \times 5 \ :Int}{x \ :Int}
}
$$

В посылке -- целочисленный x, и целочисленный результат умножения $x \times 5$. В выводе -- функция, отображающая целое число в целое число.

Применив эту фукнцию к числу, например, 8, получим значение 40, как показано на Листинге \ref{pt-4}.
\begin{lstlisting}[caption={Применение функции}, label={pt-4}]
(f 8)
> 40
\end{lstlisting}

Это тоже можно переписать в виде правила вывода, где посылкой будет отображение Int в Int и <<левой>> частью (т.е. аргументом) будет число 8 типа Int:
$$
\infer{f \ 8 \ :Int}{%
    f \ :Int \rightarrow Int & 8 \ :Int
}
$$

Теперь попробуем переписать правила вывода в обобщенном виде, заменив конкретные типы переменных в  программах выше на абстрактные типы $A$ и $B$. Point была <<собрана>> из двух целочисленных переменных, но в общем случае это может быть не так. Имеет смысл говорить о двух разных типах $A$ и $B$, которые в рассмотренных выше примерах совпадали и являлись типами Int.

Правила вывода конкретной системы типов программ выше (слева) и общем виде (справа):
\begin{equation*}
\infer{makePoint \ x \ y :Point}{%
    x \ :Int & y \ :Int
}
\qquad
\infer{\langle a, b \rangle \ :A \times B}{%
    a \ :A & b \ :B
}
\end{equation*}

\begin{equation*}
\infer{pointX \ p \ :Int}{%
    p \ :Point
}
\qquad
\infer{fst \ p \ :A}{%
    p \ :A \times B
}
\end{equation*}

\begin{equation*}
\infer{pointY \ p \ :Int}{%
    p \ :Point
}
\qquad
\infer{snd \ p \ :B}{%
    p \ :A \times B
}
\end{equation*}

\begin{equation*}
\infer{\lambda x . \ x \times 5 \ :Int \rightarrow Int}{%
    \deduce{x \times 5 \ :Int}{x \ :Int}
}
\qquad
\infer{\lambda x . \ b \ :A \rightarrow B}{%
    \deduce{b \ :B}{x \ :A}
}
\end{equation*}

\begin{equation*}
\infer{f \ 8 \ :Int}{%
    f \ :Int \rightarrow Int & 8 \ :Int
}
\qquad
\infer{f \ x \ :B}{%
    f \ :A \rightarrow B & x \ :A
}
\end{equation*}


Как можно заметить, формулы выше (правая колонка) представляют из себя типизированное лямбда-исчисление, с которым мы ранее сталкивались. При этом последние 2 формулы есть не что иное, как $\lambda$-абстракция и $\lambda$-аппликация. Мы вернемся к этим формулам позднее.


\subsection{Изоморфизм Карри-Говарда}

% TODO ref to page 2 of http://mathmod.bmstu.ru/Docs/Eduwork/ml/IU9_ML-2.pdf
Логика высказываний -- раздел математики, занимающийся анализом структуры высказываний, так же называющийся пропозициональной (лат. propositio -- предложение) логикой. Логика высказываний формализует представления о высказываниях и логических операциях над ними.

Классическое исчисление высказываний задается некоторым набором аксиом. Среди известных правил вывода можно указать т.н. modus ponens (MP):
$\infer{B}{%
    A & A \rightarrow B
}$. Она обозначает истинность формулы в выводе при истинности двух формул в посылке.

При этом в логике высказываний существуют правила естественного вывода -- они позволяют из уже известных выводимостей получать новые. Среди таких формул необходимо выделить следующие:
$$
\infer{A \land B}{%
    A & B
}
$$
\begin{equation*}
\infer{A}{%
    A \land B
}
\qquad  % разместить 2 формулы рядом
\infer{B}{%
    A \land B
}
\end{equation*}
\begin{equation*}
\infer{A \implies B}{%
    \deduce{B}{A}
}
\qquad  % разместить 2 формулы рядом
\infer{B}{%
    A \implies B & A
}
\end{equation*}

Как можно заметить, у этих формул много общего с формулами, выведенными ранее из программ.

Можно сравнить бок-о-бок полученные правила вывода. Слева -- конкретная система типов, в середине -- та же система типов, но в общем виде (типизированное лябмда-исчисление), справа -- правила естественного вывода в логике высказываний:
\begin{equation*}
\infer{makePoint \ x \ y :Point}{%
    x \ :Int & y \ :Int
}
\qquad
\infer{\langle a, b \rangle \ :A \times B}{%
    a \ :A & b \ :B
}
\qquad
\infer{A \land B}{%
    A & B
}
\end{equation*}

\begin{equation*}
\infer{pointX \ p \ :Int}{%
    p \ :Point
}
\qquad
\infer{fst \ p \ :A}{%
    p \ :A \times B
}
\qquad
\infer{A}{%
    A \land B
}
\end{equation*}

\begin{equation*}
\infer{pointY \ p \ :Int}{%
    p \ :Point
}
\qquad
\infer{snd \ p \ :B}{%
    p \ :A \times B
}
\qquad
\infer{B}{%
    A \land B
}
\end{equation*}

\begin{equation*}
\infer{\lambda x . \ x \times 5 \ :Int \rightarrow Int}{%
    \deduce{x \times 5 \ :Int}{x \ :Int}
}
\qquad
\infer{\lambda x . \ b \ :A \rightarrow B}{%
    \deduce{b \ :B}{x \ :A}
}
\qquad
\infer{A \implies B}{%
    \deduce{B}{A}
}
\end{equation*}

\begin{equation*}
\infer{f \ 8 \ :Int}{%
    f \ :Int \rightarrow Int & 8 \ :Int
}
\qquad
\infer{f \ x \ :B}{%
    f \ :A \rightarrow B & x \ :A
}
\qquad
\infer{B}{%
    A \implies B & A
}
\end{equation*}

С точностью до типов все эти формулы структурно одинаковы.

Получается, что существует связь между языком программирования и логической системой. Эта связь, а точнее изоморфизм между логической системой и типизированным исчислением, называется \textbf{соответствием Карри-Говарда} (Curry-Howard correspondence)

Структурные элементы, приведенные в Таблице \ref{iso}, благодаря соответствию, считаются эквивалентными.
\begin{table}[]
\caption{\label{iso}Эквивалентные структурные элементы}
\centering
\begin{tabular}{|l|l|}
\hline
\thead{\textbf{Логическая система}} & \thead{\textbf{Язык программирования}} \\
\hline
Высказывание                                           & Тип                                  \\ \hline
Доказательство высказывания $P$                        & Выражение типа $P$                   \\ \hline
Импликация $P \implies Q$                              & Функциональный тип $P \rightarrow Q$ \\ \hline
Доказательство импликации \\ $P \implies Q$               & Функция типа $P \rightarrow Q$       \\ \hline
Доказательство посылки $P$ \\ импликации $P \implies Q$   & Аргумент функции $P \rightarrow Q$   \\ \hline
Доказательство следствия $Q$ \\ импликации $P \implies Q$ & Результат функции $P \rightarrow Q$  \\ \hline
Конъюнкция $P \land Q$                                 & Пара (tuple) $P \times Q$            \\ \hline
Диъюнкция $P \lor Q$                                   & Тип суммы (union) $P + Q$            \\ \hline
Аксиома                                                & Примитивный тип                      \\ \hline
\end{tabular}
\end{table}

Важно заметить, что соответствие не ограничивается приведенными в Таблице \ref{iso} структурами, как не ограничивается и логикой высказываний: логика высказываний второго порядка соответствует полиморфному лямбда-исчислению, а исчисление предикатов -- лямбда-исчислению с зависимыми типами.

С практической точки зрения это означает следующее: программы на функциональном языке могут рассматриваться точно так же, как математические функции. Изоморфизм Карри-Говарда это мощный инструмент, на который можно опираться при разработке программ на типизированных функциональных языках.

Это так же доказывает, что компилятор в процессе работы не просто транслирует программу с одного языка на другой, но и проверяет доказуемость программы (через доказуемость других выражений и функций). Если же программа не скомпилируется, значит присутствует незавершенное доказательство или теорема.

Таким образом, разрабатывая программу, программист автоматически доказывает ее корректность, приводя сначала точные типы выражений (формулируя высказывания), а затем приводя реализации этих типов в виде конкретных переменных (доказывая высказывания).



\newpage

\section{КОМПИЛЯЦИЯ ПРОГРАММЫ}

Термин <<\textit{компиляция}>> уже затрагивался ранее в работе. Под компиляцией подразумевается процесс трансформации программы, написанной на исходном (высокоуровневом) языке в эквивалентную программу на целевом (как правило, низкоуровневом) языке.

Эта задача обычно выполняется компилятором -- программой, которая <<понимает>> синтаксис и низкоуровневое значение конструкций, а так же знает платформу, на которой будет исполнятся полученная программа.

Компиляция, как правило, выполняется в несколько этапов, т.н. фазы компиляции:
\begin{itemize}
    \item лексический анализ -- сканирование входного потока текста и преобразование текста в набор лексем (токены).
    \item синтаксический анализ (парсинг) -- преобразование набора токенов с прошлого шага в виде синтаксического дерева. Порядок токенов сравнивается с грамматикой языка, и парсер проверяет их на синтаксическую корректность.
    \item семантический анализ -- проверка корректности синтаксического дерева. Например, проверка типов, затронутая ранее в работе, проверка областей видимости переменных и проверка объявления переменных до использования.
    \item генерация промежуточного кода -- преобразование программы на входном языке в некий промежуточный язык, работа с которым более эффективна.
    \item оптимизация промежуточного кода -- промежуточное представление как правило может быть более эффективно оптимизировано и генерация целевого кода из него проще в реализации.
    \item кодогенерация -- оптимизированное промежуточное представление преобразуется в целевой язык
    \item оптимизация целевой программы -- для более эффективного исполнения возможна последующая обработка сгенерированного кода.
\end{itemize}

Несмотря на то, что многие целевые архитектуры, для которых компилируются программы, реализованы аппаратно, существуют так же и программные их реализации. Самая известная программная реализация -- виртуальная машина Java (Java Virtual Machine, JVM).

Следует также отметить, что компиляция изначально была процессом, выполняемым лишь раз перед запуском программы (ahead-of-time compilation, AOT), однако сейчас множество сред выполнения поддерживают динамическую компиляцию (just-in-time compilation, JIT), которая производится во время выполнения программы. Плюс этого подхода заключается в том, что во время выполнения возможно профилирование программы и становятся доступны знания о том, как именно выполняется программа. После этого некоторые фрагменты кода могут быть дополнительно скомиплированы для повышения эффективности. Этот процесс происходит дольше, но в результате программа может оказаться более производительной во время выполнения, чем ее статически-скомпилированный аналог.

В данной работе рассматривается процесс компиляции функциональных программ, которой отличается от компиляции классических императивных программ.

Мы ранее рассмотрели возможность оперирования программой в терминах математической логики. Тогда, по аналогии с эквивалентными преобразованиями логических формул, становится возможным записать эквивалентные преобразования программы на входном языке.

Опишем такие эквивалентные преобразования. Начнем с замены объявления функции на связывание (binding) лямбда-абстракции с переменной:
$$(define \ (f \ p_{formal1} \dots p_{formalN}) \ e_{body})$$
$$\equiv (define \ f \ (\lambda \ (p_{formal1} \dots p_{formalN}) \ e_{body}))$$

Преобразование условной конструкции с несколькими ветками и, ниже, с единственной веткой:
$$
(cond \ [e_{test1} \ e_{action1}] \dots [e_{testN} \ e_{actionN}])$$
$$\equiv (if \ e_{test1} \ e_{action1} \ (cond \ [e_{test2} \ e_{action2}] \dots [e_{testN} \ e_{actionN}]))$$

$$(cond \ (else \ e_{action})) \equiv e_{action}$$

Эквивалентная замена конструкции связывания на анонимную функцию:
$$(let \ ((v_{name1} \ e_{def1}) \dots(v_{nameN} \ e_{defN})) \ e_{doby})$$
$$\equiv ((\lambda \ (v_{name1} \dots v_{nameN}) \ e_{body})  \ e_{def1} \dots e_{defN})$$




% TODO ref to electronic resource http://matt.might.net/articles/desugaring-scheme/
% то что мы проделали назвывается рассахариванием

\end{document}
